
declare module 'app' {

  /**
   * @中文
   *
   * app模块提供一系列函数，用于使用其他应用、与其他应用交互。例如发送意图、打开文件、发送邮件等。
   *
   * 同时提供了方便的进阶函数startActivity和sendBroadcast，用他们可完成app模块没有内置的和其他应用的交互。
   *
   * 要导入此模块，请使用语句`const app = require('app');`，或者导入本模块的部分函数、属性`const { startActivity, packageName } = require('app');`。
   *
   * @eng
   *
   * The app module provides functions to use other applications, interact with other applications, and so on.
   *
   * It also provides advanced functions startActivity and sendBroadcast, which can be used to complete the interaction with other applications.
   *
   * To import this module, use the statement `const app = require('app');` or import the part of functions and properties `const { startActivity, packageName } = require('app');`
   *
   * @packageDocumentation
   */
  /**
   *
   * @中文
   *
   * 当前应用的包名。
   *
   * 在Auto.js Pro中运行为`org.autojs.autojspro`，在打包应用中运行为打包应用的包名。
   *
   * @eng
   *
   * The package name of the current application.
   *
   * In Auto.js Pro, it is `org.autojs.autojspro`; in released app, it is the package name of the released app.
   *
   * @example
   * ```javascript
   * "nodejs";
   * const { packageName } = require("app");
   * console.log(packageName);
   * ```
   */
  export declare const packageName: string;
  /**
   * @中文
   *
   * Intent选项，用于构建一个Intent来启动一个Activity或者发送广播等。
   *
   * 有关Intent的详细信息，参见[Intent](https://developer.android.com/reference/android/content/Intent)。
   *
   * @eng
   *
   * Intent options, used to build an Intent to start an Activity or send a broadcast.
   *
   * For more information about Intent, see [Intent](https://developer.android.com/reference/android/content/Intent).
   */
  export interface IntentOptions {
      /**
       * @中文
       *
       * 启动Activity、发送广播的目标组件的类名。
       *
       * @eng
       *
       * Target component class name, such as the class name of activity, service or broadcast.
       */
      className?: string;
      /**
       * @中文
       *
       * 目标包名。 设置一个显式的应用程序包名，该包名将限制该Intent可解析的组件。如果设置为默认值null，则所有组件都将被视为可解析。如果不为null，则Intent只能解析到给定应用程序包名中的组件。
       *
       * @eng
       *
       * The package name of the component to start. If null, all components are considered.
       */
      packageName?: string;
      /**
       * @中文
       *
       * 以键值对构成的这个Intent的Extras(额外信息)。提供该意图的其他信息，例如发送邮件时的邮件标题、邮件正文。参见[Extras](https://developer.android.com/reference/android/content/Intent.html#standard-extra-data)。
       *
       * @eng
       *
       * The Extras(extra information) of this Intent. Provide extra information for this Intent, such as the title of the email when sending an email. See [Extras](https://developer.android.com/reference/android/content/Intent.html#standard-extra-data).
       */
      extras?: any;
      /**
       * @中文
       *
       * 意图的类别。比较少用。参见[Categories](https://developer.android.com/reference/android/content/Intent.html#standard-categories)
       *
       * @eng
       *
       * The category of this Intent. See [Categories](https://developer.android.com/reference/android/content/Intent.html#standard-categories)
       */
      category?: string | Array<string>;
      /**
       * @中文
       *
       * 意图的Action，指意图要完成的动作，是一个字符串常量，比如"android.intent.action.SEND"。当action以"android.intent.action"开头时，可以省略前缀，直接用"SEND"代替。参见[Actions](https://developer.android.com/reference/android/content/Intent.html#standard-activity-actions)。
       *
       * @eng
       *
       * Set the general action to be performed, such as "android.intent.action.SEND". When the action starts with "android.intent.action", you can omit the prefix and use "SEND" instead. See [Actions](https://developer.android.com/reference/android/content/Intent.html#standard-activity-actions).
       *
       */
      action?: string;
      /**
       * @中文
       *
       * intent的额外标识，字符串或number数组，例如`["activity_new_task", "grant_read_uri_permission"]`。参见[Flags](https://developer.android.com/reference/android/content/Intent.html#setFlags%28int%29)。
       *
       * @eng
       *
       * The flags of the intent, an array of strings or numbers, e.g. `["activity_new_task", "grant_read_uri_permission"]`. See [Flags](https://developer.android.com/reference/android/content/Intent.html#setFlags%28int%29).
       * Set special flags controlling how this intent is handled. Most values here depend on the type of component being executed by the Intent, specifically the FLAG_ACTIVITY_* flags are all for use with Context.startActivity() and the FLAG_RECEIVER_* flags are all for use with Context.sendBroadcast().
       *
       */
      flags?: (string | number)[];
      /**
       * @中文
       *
       * 意图的MimeType，表示和该意图直接相关的数据的类型，表示比如"text/plain"为纯文本类型。
       *
       * @eng
       *
       * Set an explicit MIME data type.
       * This is used to create intents that only specify a type and not data, for example to indicate the type of data to return.
       *
       * Note: MIME type matching in the Android framework is case-sensitive, unlike formal RFC MIME types. As a result, you should always write your MIME types with lower case letters, or use normalizeMimeType(String) or setTypeAndNormalize(String) to ensure that it is converted to lower case.
       */
      type?: string;
      /**
       * @中文
       *
       * 意图的Data，表示和该意图直接相关的数据，是一个Uri, 可以是文件径或者Url等。例如要打开一个文件, action为"android.intent.action.VIEW", data为"file:///sdcard/1.txt"。
       *
       * @eng
       *
       * Set the data this intent is operating on, e.g. "https://www.google.com", "file://sdcard/1.txt".
       *
       * Note: scheme matching in the Android framework is case-sensitive, unlike the formal RFC. As a result, you should always write your Uri with a lower case scheme, or use Uri#normalizeScheme or setDataAndNormalize(Uri) to ensure that the scheme is converted to lower case.
       */
      data?: string | android.net.Uri;
  }
  /**
   * @中文
   *
   * 允许使用Root权限的Intent选项。Intent选项用于构建一个Intent来启动一个Activity或者发送广播等。
   *
   * 有关Intent的详细信息，参见[Intent](https://developer.android.google.cn/reference/android/content/Intent)。
   *
   * @eng
   *
   * Intent options that allow the use of the root permission. Intent options are used to build an Intent to start an Activity or send a broadcast.
   *
   * For more information about Intents, see [Intent](https://developer.android.google.cn/reference/android/content/Intent).
   *
   * @see {@link startActivity}
   * @see {@link sendBroadcast}
   */
  export interface IntentOptionsWithRoot extends IntentOptions {
      /**
       * @中文
       *
       * 是否使用Root权限，用于启动Service、Activity等。
       *
       * @eng
       *
       * Whether to use the root permission to start the service, activity, etc.
       */
      root?: boolean | undefined;
  }
  /**
   * @中文
   *
   * 根据Intent选项构造一个新的Intent。
   *
   * Intent(意图) 是一个消息传递对象，您可以使用它从其他应用组件请求操作。尽管 Intent 可以通过多种方式促进组件之间的通信，但其基本用例主要包括以下三个：
   * * 启动活动(Activity)：
   *     Activity 表示应用中的一个"屏幕"。例如应用主入口都是一个Activity，应用的功能通常也以Activity的形式独立，例如微信的主界面、朋友圈、聊天窗口都是不同的Activity。通过将 Intent 传递给 startActivity()，您可以启动新的 Activity 实例。Intent 描述了要启动的 Activity，并携带了任何必要的数据。
   * * 启动服务(Service)：
   *     Service 是一个不使用用户界面而在后台执行操作的组件。通过将 Intent 传递给 startService()，您可以启动服务执行一次性操作（例如，下载文件）。Intent 描述了要启动的服务，并携带了任何必要的数据。
   * * 传递广播：
   *     广播是任何应用均可接收的消息。系统将针对系统事件（例如：系统启动或设备开始充电时）传递各种广播。通过将 Intent 传递给 sendBroadcast()、sendOrderedBroadcast() 或 sendStickyBroadcast()，您可以将广播传递给其他应用。
   *
   * 需要注意的是，除非应用专门暴露Activity出来，否则在没有root权限的情况下使用intent是无法跳转到特定Activity、应用的特定界面的。例如我们能通过Intent跳转到QQ的分享界面，是因为QQ对外暴露了分享的Activity；而在没有root权限的情况下，我们无法通过intent跳转到QQ的设置界面，因为QQ并没有暴露这个Activity。
   * 但如果有root权限，则在intent的参数加上`"root": true`即可。例如使用root权限跳转到Auto.js的设置界面为：
   * ```
   * "nodejs";
   * const { startActivity } = require("app");
   * startActivity({
   *     packageName: "org.autojs.autojs",
   *     className: "org.autojs.autojs.ui.settings.SettingsActivity_",
   *     root: true
   * });
   * ```
   *
   * @param options 构建Intent的选项
   * @returns 新的Intent对象
   *
   * @eng
   *
   * Build a new intent from options.
   *
   * An intent is an abstract description of an operation to be performed. It can be used with startActivity to launch an Activity, broadcastIntent to send it to any interested BroadcastReceiver components, and Context.startService(Intent) or Context.bindService(Intent, ServiceConnection, int) to communicate with a background Service.
   *
   * An Intent provides a facility for performing late runtime binding between the code in different applications. Its most significant use is in the launching of activities, where it can be thought of as the glue between activities. It is basically a passive data structure holding an abstract description of an action to be performed.
   *
   *
   * @param options intent options to build intent
   * @returns The new intent object
   *
   * @example
   * ```javascript
   * "nodejs";
   * const app = require("app");
   * const i = app.makeIntent({
   *     action: "VIEW",
   *     type: "image/png",
   *     data: "file:///sdcard/1.png"
   * });
   * $autojs.androidContext.startActivity(i);
   * ```
   *
   */
  export declare function makeIntent(options: IntentOptions): any;
  /**
   *
   * @中文
   *
   * 根据选项构造一个Intent，并启动该Activity。
   *
   * @param target 目标activity的名称或者根据Intent选项构造的Activity Intent。若target为字符串，则：
   *  * console: 启动日志Activity
   *  * settings: 启动设置Activity
   * @returns Promise，如果是使用root权限，则会等待执行shell命令后返回；如果不是使用root权限，则会直接返回。**不管如何，都不会等待Activity启动才返回。**
   *
   *
   * @eng
   *
   * Build a new intent from options and start the activity.
   *
   * @param target activity name or activity intent to start. If target is a string, then:
   * * console: start LogActivity
   * * settings: start SettingsActivity
   * @returns Promise, if using root permission, will wait for shell command to finish; if not using root permission, will return immediately. **Never wait for activity to start before returning.**
   *
   * @see {@link makeIntent}
   *
   * @example
   * ```javascript
   * "nodejs";
   * const { startActivity } = require("app");
   * startActivity({
   *     action: "SEND",
   *     type: "text/plain",
   *     data: "file:///sdcard/1.txt"
   * });
   * ```
   */
  export declare function startActivity(target: "console" | "settings" | IntentOptionsWithRoot): Promise<void>;
  /**
   * @中文
   *
   * 根据选项构造一个Intent，并启动该服务。
   *
   * @param target 构造Service Intent的选项
   * @returns Promise，如果是使用root权限，则会等待执行shell命令后返回；如果不是使用root权限，则会直接返回。**不管如何，都不会等待Service启动才返回。**
   *
   * @eng
   *
   * Build a new intent from options and start the service.
   *
   * @param target service options to build service intent
   * @returns Promise, if using root permission, will wait for shell command to finish; if not using root permission, will return immediately. **Never wait for service to start before returning.**
   *
   * @see {@link makeIntent}
   *
   */
  export declare function startService(target: IntentOptionsWithRoot): Promise<void>;
  /**
   * @中文
   *
   * 根据选项构造一个Intent，并发送该广播。
   *
   * @param target 目标广播的名称或者根据Intent选项构造的广播 Intent。若target为字符串，则：
   *     * `inspect_layout_hierarchy` 布局层次分析
   *     * `inspect_layout_bounds` 布局范围分析
   * 但是这些广播在打包后应用中不可用。
   *
   * @returns Promise，如果是使用root权限，则会等待执行shell命令后返回；如果不是使用root权限，则会直接返回。
   *
   * @eng
   *
   * Build a new intent from options and send the broadcast.
   *
   * @param target broadcast name or broadcast intent to send. If target is a string, then:
   *   * `inspect_layout_hierarchy` inspect layout hierarchy
   *   * `inspect_layout_bounds` inspect layout bounds
   * But these broadcasts are not available in release apps.
   *
   * @returns Promise, if using root permission, will wait for shell command to finish; if not using root permission, will return immediately.
   *
   * @see {@link makeIntent}
   *
   */
  export declare function sendBroadcast(target: IntentOptionsWithRoot): Promise<void>;
  /**
   * @中文
   *
   * 发送邮件的选项
   *
   * @eng
   *
   * Options to send email
   *
   * @see {@link sendEmail}
   */
  export interface EmailOptions {
      /**
       * @中文
       *
       * 收件人的邮件地址。如果有多个收件人，则用字符串数组表示
       *
       * @eng
       *
       * Email address of the recipient. If there are multiple recipients, then use an array to represent them.
       */
      email: string | Array<string>;
      /**
       * @中文
       *
       * 抄送收件人的邮件地址。如果有多个抄送收件人，则用字符串数组表示
       *
       * @eng
       *
       * Email address of the carbon copy recipient. If there are multiple carbon copy recipients, then use an array to represent them.
       *
       */
      cc?: string | Array<string>;
      /**
       * @中文
       *
       * 密送收件人的邮件地址。如果有多个密送收件人，则用字符串数组表示
       *
       * @eng
       *
       * Email address of the blind carbon copy recipient. If there are multiple blind carbon copy recipients, then use an array to represent them.
       */
      bcc?: string | Array<string>;
      /**
       * @中文
       *
       * 邮件主题(标题)
       *
       * @eng
       *
       * Email subject(title).
       *
       */
      subject?: string;
      /**
       * @中文
       *
       * 邮件正文
       *
       * @eng
       *
       * Email body.
       */
      text?: string;
      /**
       * @中文
       *
       * 附件的路径。
       *
       * @eng
       *
       * Path of the attachment.
       */
      attachment?: string;
      /**
       * @中文
       *
       * 若有多个邮件应用，该标题会在用户选择界面显示。
       *
       * @eng
       *
       * If there are multiple email applications, this title will be displayed in the user selection interface.
       */
      chooserTitle?: string;
  }
  /**
   * @中文
   *
   * 启用发送邮件的应用。如果没有安装邮箱应用，则抛出`ActivityNotException`。
   *
   * @param options 邮件发送选项
  
  * @eng
   *
   * Start the email application. If there is no email application, then throw `ActivityNotException`.
   *
   * @param options Email sending options
   *
   */
  export declare function sendEmail(options: EmailOptions): void;
  /**
   * @中文
   *
   * 通过应用名称启动应用。如果该名称对应的应用不存在，则返回false；否则返回true。如果该名称对应多个应用，将随机启动其中一个。
   *
   * **注意！**在高版本Android或部分系统上，会限制通过后台启动应用，也即在后台的情况下即使返回true，也可能没有实际启动该应用。
   *
   * @param targetAppName 要启动的应用名称
   * @returns 是否找到该应用，并不返回是否真正启动成功
   *
   * @eng
   *
   * Start the application by application name. If the application does not exist, then return false; otherwise return true. If the application name corresponds to multiple applications, then randomly start one of them.
   *
   * **Note!** On some Android versions, the application may be limited to start in the background, even if the return value is true, and it may not actually start the application.
   *
   * @param targetAppName Name of the application to start
   * @returns Whether the application exists, instead of whether it is actually launched successfully.
   *
   * @see [Restrictions on starting activities from the background](https://developer.android.com/guide/components/activities/background-starts)
   *
   */
  export declare function launchApp(targetAppName: string): boolean;
  /**
   * @中文
   *
   * 获取应用名称对应的已安装的应用的包名。如果该找不到该应用，返回null；如果该名称对应多个应用，则只返回其中某一个的包名。
   *
   * @param targetAppName 应用名称
   * @returns 名称对应的包名，或者null
   *
   * @eng
   *
   * Get the package name corresponding to the application name. If the application does not exist, then return null; if the application name corresponds to multiple applications, then only return the package name of one of them.
   *
   * @param targetAppName Application name
   * @returns Package name, or null
   *
   */
  export declare function getPackageName(targetAppName: string): string | null;
  /**
   * @中文
   *
   * 通过应用包名启动应用。如果该包名对应的应用不存在，则返回false；否则返回true。
   *
   * **注意！**在高版本Android或部分系统上，会限制通过后台启动应用，也即在后台的情况下即使返回true，也可能没有实际启动该应用。
   *
   * @param packageName 要启动的应用包名
   * @returns 是否找到该应用，并不返回是否真正启动成功
   *
   * @eng
   *
   * Start the application by package name. If the application does not exist, then return false; otherwise return true.
   *
   * **Note!** On some Android versions, the application may be limited to start in the background, even if the return value is true, and it may not actually start the application.
   *
   * @param packageName Package name of the application to be launched.
   * @returns Whether the application exists, instead of whether it is actually launched successfully.
   *
   * @see [Restrictions on starting activities from the background](https://developer.android.com/guide/components/activities/background-starts)
   *
   */
  export declare function launch(packageName: string): boolean;
  /**
   * @中文
   *
   * 根据选项构造一个Intent，转换为对应的shell的intent命令的参数。
   *
   * @param options Intent选项
   *
   * @returns 对应的shell的intent命令的参数
   *
   * @eng
   *
   * Construct an Intent according to the options, and convert it to the corresponding shell intent command parameters.
   *
   * @param options Intent options
   *
   * @returns The corresponding shell intent command parameters
   *
   * @see [adb am](https://developer.android.com/studio/command-line/adb#am)
   *
   * @example
   * ```javascript
   * "nodejs";
   * const { intentToShell } = require("app");
   * const { exec } = require("shell");
   * exec("am start " + intentToShell({
   *     packageName: "org.autojs.autojs",
   *     className: "org.autojs.autojs.ui.settings.SettingsActivity_"
   * }), { root: true});
   * ```
   */
  export declare function intentToShell(options: IntentOptions): string;
  /**
   * @中文
   * 解析uri字符串并返回相应的Uri对象。即使Uri格式错误，该函数也会返回一个Uri对象，但之后如果访问该对象的scheme, path等值可能因解析失败而返回`null`。
   *
   * 在高版本Android上，由于系统限制直接在Uri暴露文件的绝对路径，因此如果uri字符串是文件`file://...`，返回的Uri会是诸如`content://...`的形式。
   *
   * @param uri uri字符串或uri对象，后者直接返回uri自身
   * @returns 解析后的Uri对象
   *
   * @eng
   *
   * Parse uri string or uri object and return the corresponding Uri object. If the uri string is invalid, the function will return a Uri object, but the values of scheme, path, etc. may be `null`.
   *
   * On higher version Android, since the system restricts the absolute path of a file, the Uri returned by this function may be a content uri like `content://...` if the uri string is `file://...`
   *
   * @param uri uri string or uri object, the latter directly return the uri itself
   * @returns parsed Uri object
   *
   */
  export declare function parseUri(uri: string | android.net.Uri): android.net.Uri;
  /**
   *
   * @中文
   *
   * 从一个文件路径创建一个uri对象在高版本Android上，由于系统限制直接在Uri暴露文件的绝对路径，因此返回的Uri会是诸如`content://...`的形式。
   *
   * @param pathOrUri 文件路径或文件uri，比如"/sdcard/1.txt"或"file:///sdcard/1.txt"
   * @returns 文件uri，可作为Intent的data属性
   *
   * @eng
   *
   * Create a uri object from a file path or uri string. In higher version Android, the uri returned will be a content uri.
   *
   * @param pathOrUri pathOrUri file path or file uri, for example "/sdcard/1.txt" or "file:///sdcard/1.txt"
   * @returns file uri, can be used as Intent's data property
   */
  export declare function getUriForFile(pathOrUri: string): android.net.Uri;
  /**
   *
   * @中文
   *
   * 获取应用包名对应的已安装的应用的名称。如果该找不到该应用，返回null。
   *
   * @param packageName 应用包名
   * @returns 应用名称，或者null
   *
   * @eng
   *
   * Get the app name for the given package name. If the app of the given package name is not found, returns null.
   *
   * @param packageName package name
   * @returns the app name of the given package name, or null if not found
   */
  export declare function getAppName(packageName: string): string | null;
  /**
   * @中文
   *
   * 打开应用的详情页(设置页)。如果找不到该应用，返回false; 否则返回true。
   *
   * @param packageName 包名
   * @returns 是否成功打开应用设置页
   *
   * @eng
   *
   * Open the details page of the app. If the app is not found, return false; otherwise return true.
   *
   * @param packageName package name
   * @returns whether the app is found
   *
   */
  export declare function openAppSettings(packageName: string): boolean;
  /**
   * @中文
   *
   * 卸载应用。执行后会会弹出卸载应用的提示框。如果该包名的应用未安装，由应用卸载程序处理，可能弹出"未找到应用"的提示。
   *
   * @param packageName 包名
   *
   * @eng
   *
   * Uninstall application. Will pop up uninstall application dialog. If the package name of the application is not installed, the application uninstaller will handle it, which may pop up a "not found" prompt.
   *
   * @param packageName the package name to uninstall
   *
   */
  export declare function uninstall(packageName: string): void;
  /**
   * @中文
   *
   * 用其他应用查看文件。文件不存在的情况由查看文件的应用处理。
   * 如果找不出可以查看该文件的应用，则抛出`ActivityNotException`。
   * ```
   * "nodejs";
   * const app = require("app");
   * app.viewFile("/sdcard/1.txt");
   * ```
   * @param file 文件路径
   *
   * @eng
   *
   * Open file with other apps. The case of file not exist will be handled by the app that open the file.
   * If can't find the app to open the file, it will throw `ActivityNotException`.
   *
   */
  export declare function viewFile(file: string): void;
  /**
   *
   * @中文
   *
   * 用其他应用编辑文件。文件不存在的情况由编辑文件的应用处理。
   * 如果找不出可以编辑该文件的应用，则抛出`ActivityNotException`。
   *
   * @param file 文件路径
   *
   * @eng
   *
   * Edit file with other apps. The case that file does not exist is handled by the third party app.
   * If no app can edit the file, then throw `ActivityNotException`.
   *
   * @example
   * ```javascript
   * "nodejs";
   * const app = require("app");
   * app.editFile("/sdcard/1.txt/);
   * ```
   */
  export declare function editFile(file: string): void;
  /**
   * @中文
   *
   * 用浏览器打开网站url。
   * 如果没有安装浏览器应用，则抛出`ActivityNotException`。
   *
   * @param url 网站的Url，需要以"http://"或"https://"开头。
   *
   * @eng
   *
   * Open website with browser.
   * If no browser app installed, then throw `ActivityNotException`.
   *
   * @param url The url of the website, must start with "http://" or "https://".
   *
   */
  export declare function openUrl(url: string): void;
  /**
   * @中文
   *
   * 获取已安装的应用列表的过滤选项。
   *
   * @eng
   *
   * The filter options of the installed apps.
   *
   * @see {@link getInstalledApps}
   */
  export interface PMOptions {
      /**
       * @中文
       *
       * 指定返回的应用信息中包含的信息，例如`["activities", "meta_data"]`。
       *
       * 可能的值包括：
       *
       * * `"activities"` 应用的Activity组件信息
       * * `"configurations"` 应用的硬件配置
       * * `"gids"` 应用的group id
       * * `"instrumentation"` 应用的Instrumentation信息
       * * `"intent_filters"` 应用的意图过滤
       * * `"meta_data"` 应用的元信息（默认）
       * * `"permissions"` 应用的权限信息
       * * `"providers"` 应用的ContentProvider组件信息
       * * `"receivers"` 应用的BroadcastReceiver组件信息
       * * `"services"` 应用的Service组件信息
       * * `"shared_library_files"` 应用的动态链接库文件信息
       * * `"signatures"` 应用的签名信息（已弃用
       * * `"signing_certificates"` 应用的签名信息
       * * `"uri_permission_patterns"`
       * * `"disabled_components"` 被卸载的但保留了数据的应用
       * * `"disabled_until_used_components"` 禁用直到被使用的组件
       * * `"uninstalled_packages"` 被卸载的但保留了数据的应用
       *
       * @eng
       *
       * The information of the app to be returned, for example `["activities", "meta_data"]`.
       *
       * Possible values include:
       *
       * * `"activities"` The activity components of the app
       * * `"configurations"` The hardware configuration of the app
       * * `"gids"` The group id of the app
       * * `"instrumentation"` The instrumentation of the app
       * * `"intent_filters"` The intent filters of the app
       * * `"meta_data"` The meta data of the app (default)
       * * `"permissions"` The permissions of the app
       * * `"providers"` The content provider components of the app
       * * `"receivers"` The broadcast receiver components of the app
       * * `"services"` The service components of the app
       * * `"shared_library_files"` The shared library files of the app
       * * `"signatures"` The signatures of the app (deprecated)
       * * `"signing_certificates"` The signing certificates of the app
       * * `"uri_permission_patterns"`
       * * `"disabled_components"` The disabled components of the app
       * * `"disabled_until_used_components"` The disabled until used components of the app
       * * `"uninstalled_packages"` The uninstalled packages of the app
       *
       * @see [PackageManager.GET_*](https://developer.android.com/reference/android/content/pm/PackageManager#GET_ACTIVITIES)
       */
      get?: Array<string>;
      /**
       * @中文
       *
       * 指定要匹配的应用列表，例如`["disabled_components", "uninstalled_packages"]`。
       *
       * * `"uninstalled_packages"` 被卸载的但保留了数据的应用
       * * `"disabled_components"` 被禁用的组件
       * * `"disabled_until_used_components"` 禁用直到被使用的组件
       * * `"system_only"` 只匹配系统应用
       * * `"factory_only"` 只匹配预装应用
       * * `"apex"` APEX应用
       *
       * @eng
       *
       * The list of apps to be matched, for example `["disabled_components", "uninstalled_packages"]`.
       *
       * * `"uninstalled_packages"` Flag parameter to retrieve some information about all applications (even uninstalled ones) which have data directories. This state could have resulted if applications have been deleted with flag DELETE_KEEP_DATA with a possibility of being replaced or reinstalled in future.
       *      Note: this flag may cause less information about currently installed applications to be returned.
       *      Note: use of this flag requires the android.permission.QUERY_ALL_PACKAGES permission to see uninstalled packages.
       * * `"disabled_components"` include disabled components in the returned info
       * * `"disabled_until_used_components"` nclude disabled components which are in that state only because of COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED in the returned info. Note that if you set this flag, applications that are in this disabled state will be reported as enabled
       * * `"system_only"`  include only components from applications that are marked with ApplicationInfo#FLAG_SYSTEM.
       * * `"factory_only"` The factory only apps
       * * `"apex"`  include APEX packages that are currently installed. In APEX terminology, this corresponds to packages that are currently active, i.e. mounted and available to other processes of the OS. In particular, this flag alone will not match APEX files that are staged for activation at next reboot.
       *
       * @see [PackageManager.MATCH_*](https://developer.android.com/reference/android/content/pm/PackageManager#MATCH_SYSTEM_ONLY)
       */
      match?: Array<string>;
  }
  /**
   * @中文
   *
   * 获取安装的应用列表。
   *
   * 返回值是ApplicationInfo对象的数组。 如果没有安装任何应用，则返回一个空数组。
   *
   * 选项options的match选项用于指定要返回哪些应用程序，get选项用于指定返回的应用程序携带哪些信息。
   *
   * @eng
   *
   * Get the list of installed applications.
   *
   * Returns an array of ApplicationInfo objects. If there are no installed applications, an empty array is returned.
   *
   * Options options.match specifies which applications to return. Options options.get specifies which information about each application to return.
   *
   * @example
   * ```javascript
   * "nodejs";
   * const app = require("app");
   * const apps = app.getInstalledApps({
   *     get: ['meta_data'],
   *     match: ['system_only']
   * });
   * console.log(apps);
   * ```
   * @param options 过滤选项
   * @returns 为当前用户安装的所有应用程序包的列表。如果设置了match选项 `uninstalled_packages`，则包括被删除但保留了数据的应用程序。
   *
   * @see [PackageManager.getInstalledApplication](https://developer.android.com/reference/android/content/pm/PackageManager#getInstalledApplications(int))
   *
   */
  export declare function getInstalledApps(options?: PMOptions): Array<android.content.pm.ApplicationInfo>;
  /**
   *
   * @中文
   *
   * 获取安装的应用列表。
   *
   * @param options 过滤选项
   * @returns PackageInfo对象的数组。 如果没有安装任何应用，则返回一个空数组。
   *
   * @eng
   *
   * Get the list of installed applications.
   *
   * @param options options.match specifies which applications to return. Options options.get specifies which information about each application to return.
   * @returns An array of PackageInfo objects. If there are no installed applications, an empty array is returned.
   *
   * @see [PackageManager.getInstalledPackages](https://developer.android.com/reference/android/content/pm/PackageManager#getInstalledPackages(int))
   *
   */
  export declare function getInstalledPackages(options?: PMOptions): Array<android.content.pm.PackageInfo>;
  /**
   * @中文
   *
   * 解析apk文件并返回包信息。
   *
   * @param file 文件路径
   * @param options 过滤选项
   * @returns 包信息，若apk无法解析，返回null
   *
   * @eng
   *
   * Parse an APK file and return the package info.
   *
   * @param file The file path.
   * @param options the filter options
   * @returns A PackageInfo object containing information about the package archive. If the package could not be parsed, returns null.
   *
   * @see [PackageManager.getPackageArchiveInfo](https://developer.android.com/reference/android/content/pm/PackageManager#getPackageArchiveInfo(java.lang.String,%20int))
   *
   * @example
   * ```javascript
   * "nodejs";
   * const app = require("app");
   * const info = app.getApkInfo("/path/to/apk", {
   *    get: ['meta_data'],
   * });
   * console.log(info.packageName);
   * ```
   *
   */
  export declare function getApkInfo(file: string, options?: PMOptions): android.content.pm.PackageInfo | null;
  

}

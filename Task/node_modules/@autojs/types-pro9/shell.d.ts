/// <reference types="node" />

declare module 'shell' {

  import EventEmitter from "events";
  /**
   * @中文
   *
   * shell命令执行结果。由{@link Shell.exec}和{@link exec}返回。
   *
   * @eng
   *
   * Shell command execution result. Returned by {@link Shell.exec} and {@link exec}.
   */
  export interface ExecutionResult {
      /**
       * @中文
       *
       * 命令执行的返回码，即退出代码。一般0表示执行成功，其他值表示执行失败。
       *
       * @eng
       *
       * Exit code of the command. 0 means success, other values mean failure.
       */
      readonly code: number;
      /**
       * @中文
       *
       * 命令执行的输出。包含标准输出和标准错误输出。
       *
       * @eng
       *
       * Output of the command. Includes standard output and standard error.
       */
      readonly output: string;
      /**
       * @中文
       *
       * 命令执行的标准输出。比如`ls`命令的stdout是文件列表。
       *
       * @eng
       *
       * Standard output of the command. For example, `ls` command's stdout is a list of files.
       */
      readonly stdout: string;
      /**
       * @中文
       *
       * 命令执行的标准错误输出。
       *
       * @eng
       *
       * Standard error of the command.
       */
      readonly stderr: string;
  }
  export declare type ExitResult = string | number;
  export declare type StandardOutputType = "stderr" | "stdout";
  /**
   * @中文
   *
   * Shell类，通过{@link createShell}创建新实例。
   *
   * @eng
   *
   * Shell class. Created new instance by {@link createShell}.
   */
  export interface Shell extends EventEmitter {
      /**
       * @中文
       *
       * 往shell的标准输入中提交文本内容，若文本内容末尾未包含换行符，则会自动添加换行符。
       *
       * @eng
       *
       * Submit text to shell's standard input. If the text does not end with a newline character, a newline character will be appended automatically.
       */
      submit(input: string): void;
      /**
       * @中文
       *
       * 执行shell命令，并等待执行结果。
       *
       * @param cmd 要执行的命令
       * @returns 执行结果的Promise
       *
       * @eng
       *
       * Execute a shell command and wait for the result asynchronously.
       *
       * @param cmd Shell command to execute
       * @returns Promise of the execution result
       *
       * @example
       * ```javascript
       * "nodejs";
       * const { createShell } = require('shell');
       * async function main() {
       *     const shell = createShell();
       *     console.log(await shell.exec("touch test.txt"));
       *     console.log(await shell.exec("ls -l test.txt"));
       *     await shell.exit();
       * }
       * main();
       * ```
       */
      exec(cmd: string): Promise<ExecutionResult>;
      /**
       * @中文
       *
       * 退出shell进程。若forcedly为true，则会直接杀死进程，此时返回值为字符串，表示杀死进程的signal；如果forcedly为false，则会使用`exit`命令退出shell进程，并返回退出码(exit code)。
       *
       * @param forcedly 是否强制退出
       *
       * @eng
       *
       * Exit the shell process. If forcedly is true, the process will be terminated and the return value will be a string representing the signal that killed the process. If forcedly is false, the process will be terminated by `exit` command and the return value will be the exit code.
       */
      exit(forcedly?: boolean): Promise<ExitResult>;
      /**
       * @中文
       *
       * shell的标准输出或标准输出结果有新数据的事件。`type`参数用于区分是标准输出还是标准错误输出。
       *
       * @event data
       *
       * @eng
       *
       * Event emitted when shell's standard output or standard error has new data. `type` parameter is used to distinguish standard output and standard error.
       *
       * @event data
       */
      on(event: "data", listener: ((chunk: Buffer, type: StandardOutputType) => void)): this;
      /**
       * @中文
       *
       * shell的标准输出或标准输出结果有新的一行数据的事件。`type`参数用于区分是标准输出还是标准错误输出。
       *
       * @event line
       *
       * @eng
       *
       * Event emitted when shell's standard output or standard error has new line. `type` parameter is used to distinguish standard output and standard error.
       *
       * @event line
       */
      on(event: "line", listener: ((line: string, type: StandardOutputType) => void)): this;
  }
  /**
   * @中文
   *
   * Shell选项。用于创建新的Shell或RootAutomator时指定。参见{@link createShell}和{@link setDefaultShellOptions}。
   *
   * @eng
   *
   * Shell options. Used to specify options when creating a new Shell or RootAutomator. See {@link createShell} and {@link setDefaultShellOptions}.
   */
  export interface ShellOptions {
      /**
       * @中文
       *
       * 是否使用Root权限。
       *
       * @eng
       *
       * Whether to use root permission.
       */
      root?: boolean;
      /**
       * @中文
       *
       * 是否使用adb shell（当前实现为Shizuku）。
       *
       * @eng
       *
       * Whether to use adb shell (currently implemented as Shizuku).
       */
      adb?: boolean;
      /**
       * @中文
       *
       * 环境变量，例如 `{PATH: "/data/local/tmp"}`。
       *
       * @eng
       *
       * Environment variables, e.g. `{PATH: "/data/local/tmp"}`.
       */
      env?: NodeJS.ProcessEnv;
  }
  /**
   * @中文
   *
   * 设置默认的Shell选项。这些选项包含是否使用Root权限、adb权限、环境变量等，会在创建新的Shell或RootAutomator实例时使用。
   *
   * @param options Shell选项
   *
   * @eng
   *
   * Set default options for Shell. These options include whether to use Root permission, adb permission, environment variables, etc. They will be used when creating new Shell or RootAutomator instance.
   *
   * @param options Shell options
   */
  export declare function setDefaultShellOptions(options: ShellOptions): void;
  /**
   * @中文
   *
   * 获取默认的Shell选项。
   *
   * @eng
   *
   * Get default options for Shell.
   *
   * @see {@link setDefaultShellOptions}
   */
  export declare function getDefaultShellOptions(): ShellOptions;
  /**
   * @中文
   *
   * 创建一个Shell实例。
   *
   * 我们通常用{@link exec}函数来一次性执行单条命令并获取结果，但如果有多条命令需要执行，用Shell对象的效率更高。这是因为无需每次执行都创建新的shell进程。
   *
   * 通过Shell对象我们也可监听到Shell的输出。
   *
   * @param options Shell选项，将覆盖默认的Shell选项
   * @returns Shell实例
   *
   * @eng
   *
   * Create a Shell instance.
   *
   * We usually use {@link exec} function to execute a single command and get the result, but if there are multiple commands to execute, the efficiency of Shell object is higher. This is because we don't need to create a new shell process every time we execute.
   *
   * We can also listen to Shell's output by using Shell object.
   *
   * @param options Shell options, will override default options
   * @returns New shell instance
   *
   * @example
   * ```javascript
   * "nodejs";
   * const { createShell } = require("shell");
   * const shell = createShell();
   * shell.on("line", (line) => {
   *     console.log(line);
   * });
   * shell.exec("ls");
   *
   * const id = $autojs.keepRunning();
   * shell.exit().then(() => $autojs.cancelKeepRunning(id));
   *
   * ```
   */
  export declare function createShell(options?: ShellOptions): Shell;
  /**
   * @中文
   *
   * 创建一个新的shell进程，并执行命令，异步返回结果。
   *
   * @param cmd 要执行的命令
   * @param options Shell选项，将覆盖默认的Shell选项
   * @returns 执行结果的Promise
   *
   * @eng
   *
   * Create a new shell process, and execute a command, return the result asynchronously.
   *
   * @param cmd Command to execute
   * @param options Shell options, will override default options
   * @returns Promise of execution result
   *
   * @example
   * ```javascript
   * "nodejs";
   * const { exec, isRootAvailable } = require("shell");
   * async function main() {
   *     console.log(await exec("npm"));
   *     if (await isRootAvailable()) {
   *        console.log(await exec("ls /data", { root: true }));
   *     }
   * }
   * main();
   * ```
   */
  export declare function exec(cmd: string, options?: ShellOptions): Promise<ExecutionResult>;
  export declare type PrivilegeType = "root" | "adb";
  /**
   * @中文
   *
   * 检查是否有特定的特权，比如是否有root权限。
   *
   * @param type 特权类型，比如"root"或"adb"
   * @returns 是否有该类型的特权的Promise
   *
   * @eng
   *
   * Check if there is a specific privilege, such as whether there is root permission.
   *
   * @param type Privilege type, such as "root" or "adb"
   * @returns Whether there is a specific privilege
   *
   * @example
   * ```javascript
   * "nodejs";
   *
   * const { checkAccess } = require("shell");
   * async function main() {
   *    const hasRoot = await checkAccess("root");
   *    const hasAdb = await checkAccess("adb");
   *    console.log(`hasRoot: ${hasRoot}, hasAdb: ${hasAdb}`);
   * }
   * main();
   * ```
   */
  export declare function checkAccess(type: PrivilegeType): Promise<boolean>;
  /**
   * @中文
   *
   * 检查设备是否已Root。需要注意的是，设备已Root不代表本应用已获得Root权限。
   *
   * @eng
   *
   * Check if device is rooted. Note that device is rooted does not mean this app has root permission.
   *
   * @example
   * ```javascript
   * "nodejs";
   *
   * const { isRootAvailable } = require("shell");
   * async function main() {
   *    const rootAvailable = await isRootAvailable();
   *    console.log(`rootAvailable: ${rootAvailable}`);
   * }
   * main();
   * ```
   */
  export declare function isRootAvailable(): Promise<boolean>;
  /**
   * @中文
   *
   * 使用默认的shell示例执行`input tab x y`命令，模拟点击位置(x, y)。
   *
   * 默认的shell示例在首次使用{@link Tap}, {@link Swipe}, {@link SendKey}, {@link InputText}等操作时会使用默认Shell选项{@link getDefaultShellOptions}自动创建。若您想让这些操作使用adb权限或特定Shell选项，应当在执行这些函数前使用{@link setDefaultShellOptions}设置Shell选项。
   *
   * 这些操作函数以大写字母开头，表示其通常需要root或adb权限，否则只能在本应用内生效。
   *
   *
   * @eng
   *
   * Use default shell instance to execute `input tab` command, simulate clicking position (x, y).
   *
   * Default shell instance will be created automatically when using {@link Tap}, {@link Swipe}, {@link SendKey}, {@link InputText} etc. If you want to use adb permission or specific shell options, you should use {@link setDefaultShellOptions} before using these functions.
   *
   * These functions start with uppercase letter, which means they require root or adb permission, otherwise they only work in this app.
   *
   * @example
   *
   * ```javascript
   * "nodejs";
   * const { Tap } = require("shell");
   * async function main() {
   *     await Tap(100, 100);
   * }
   * main();
   * ```
   */
  export declare function Tap(x: number, y: number): Promise<void>;
  /**
   * @中文
   *
   * 使用默认的shell示例执行`input swipe x1 y1 x2 y2 duration`命令，模拟从位置(x1, y1)滑动到位置(x2, y2)。
   *
   * 默认的shell示例在首次使用{@link Tap}, {@link Swipe}, {@link SendKey}, {@link InputText}等操作时会使用默认Shell选项{@link getDefaultShellOptions}自动创建。若您想让这些操作使用adb权限或特定Shell选项，应当在执行这些函数前使用{@link setDefaultShellOptions}设置Shell选项。
   *
   * 这些操作函数以大写字母开头，表示其通常需要root或adb权限，否则只能在本应用内生效。
   *
   * @param duration 滑动时间，单位毫秒
   *
   * @eng
   *
   * Use default shell instance to execute `input swipe x1 y1 x2 y2 duration` command, simulate sliding from position (x1, y1) to position (x2, y2).
   *
   * Default shell instance will be created automatically when using {@link Tap}, {@link Swipe}, {@link SendKey}, {@link InputText} etc. If you want to use adb permission or specific shell options, you should use {@link setDefaultShellOptions} before using these functions.
   *
   * These functions start with uppercase letter, which means they require root or adb permission, otherwise they only work in this app.
   *
   * @param duration Swipe duration, unit is millisecond
   *
   * @example
   *
   * ```javascript
   * "nodejs";
   * const { Swipe } = require("shell");
   * async function main() {
   *     await Swipe(800, 100, 800, 1000);
   * }
   * main();
   * ```
   */
  export declare function Swipe(x1: number, y1: number, x2: number, y2: number, duration?: number): Promise<void>;
  /**
   * @中文
   *
   * 使用默认的shell示例执行`input keyevent key`命令，模拟发送按键key。
   *
   * 默认的shell示例在首次使用{@link Tap}, {@link Swipe}, {@link SendKey}, {@link InputText}等操作时会使用默认Shell选项{@link getDefaultShellOptions}自动创建。若您想让这些操作使用adb权限或特定Shell选项，应当在执行这些函数前使用{@link setDefaultShellOptions}设置Shell选项。
   *
   * 这些操作函数以大写字母开头，表示其通常需要root或adb权限，否则只能在本应用内生效。
   *
   * @param key 按键名或按钮码，比如"HOME"或3表示Home按键，参见[KeyEvent](https://developer.android.com/reference/android/view/KeyEvent#KEYCODE_HOME)。
   *
   * @eng
   *
   * Use default shell instance to execute `input keyevent key` command, simulate sending key.
   *
   * Default shell instance will be created automatically when using {@link Tap}, {@link Swipe}, {@link SendKey}, {@link InputText} etc. If you want to use adb permission or specific shell options, you should use {@link setDefaultShellOptions} before using these functions.
   *
   * These functions start with uppercase letter, which means they require root or adb permission, otherwise they only work in this app.
   *
   * @param key Key name or key code, like "HOME" or 3, see [KeyEvent](https://developer.android.com/reference/android/view/KeyEvent#KEYCODE_HOME)
   *
   * @example
   *
   * ```javascript
   * "nodejs";
   * const { SendKey, setDefaultShellOptions } = require("shell");
   *
   * async function main() {
   *     setDefaultShellOptions({
   *        adb: true,
   *     });
   *     await SendKey("HOME");
   * }
   * main();
   * ```
   */
  export declare function SendKey(key: number | string): Promise<void>;
  /**
   * @中文
   *
   * 使用默认的shell示例执行`input text`命令，模拟输入文字。
   *
   * 默认的shell示例在首次使用{@link Tap}, {@link Swipe}, {@link SendKey}, {@link InputText}等操作时会使用默认Shell选项{@link getDefaultShellOptions}自动创建。若您想让这些操作使用adb权限或特定Shell选项，应当在执行这些函数前使用{@link setDefaultShellOptions}设置Shell选项。
   *
   * 这些操作函数以大写字母开头，表示其通常需要root或adb权限，否则只能在本应用内生效。
   *
   * @param text 要输入的文字，只支持ASCII字符，不支持中文
   *
   * @eng
   *
   * Use default shell instance to execute `input text` command, simulate inputting text.
   *
   * Default shell instance will be created automatically when using {@link Tap}, {@link Swipe}, {@link SendKey}, {@link InputText} etc. If you want to use adb permission or specific shell options, you should use {@link setDefaultShellOptions} before using these functions.
   *
   * These functions start with uppercase letter, which means they require root or adb permission, otherwise they only work in this app.
   *
   * @param text Text to input, only support ASCII characters
   *
   * @example
   *
   * ```javascript
   * "nodejs";
   * const { InputText } = require("shell");
   * async function main() {
   *     await InputText("Hello, World");
   * }
   * main();
   * ```
   */
  export declare function InputText(text: string): Promise<void>;
  

}

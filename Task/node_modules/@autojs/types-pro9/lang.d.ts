
declare module 'lang' {

  /**
   * @中文
   *
   * TypeScript装饰器，在JavaScript中无法使用。
   *
   * 用于装饰类的getter属性，装饰后的属性在第一个调用时会被自动执行并保存值，以后调用时会使用之前保存的值。
   *
   * @eng
   *
   * TypeScript decorator, which cannot be used in JavaScript.
   *
   * Decorates class's getter properties, and the decorated properties will be automatically executed and saved the value on the first call, and then use the saved value on subsequent calls.
   *
   * @example
   * ```typescript
   * import { lazy } from 'lang'
   *
   * class Sum {
   *    private n: number;
   *
   *    constructor(n: number) {
   *      this.n = n;
   *    }
   *
   *    @lazy
   *    get sum() {
   *      console.log('calculating sum...');
   *      let result = 0;
   *      for (let i = 0; i < this.n; i++) {
   *           result += i;
   *      }
   *      return result;
   *    }
   * }
   *
   * const sum = new Sum(10);
   * console.log(sum.sum); // calculating sum...55
   * console.log(sum.sum); // 55
   * ```
   *
   */
  export declare function lazy(target: any, name: string, { get: initializer, enumerable, configurable, set: setter }?: PropertyDescriptor): any;
  export interface ReadOnlyProperty<T> {
      get(): T;
  }
  export declare function lazyProp<T>(evaluator: () => T): ReadOnlyProperty<T>;
  /**
   * @中文
   *
   * 创建一个Promise，与`new Promise`类似，唯一不同的是在此Promise状态在pending状态时（也即resolve/reject之前），autojs会保持引擎不退出。
   *
   * 由于nodejs并不感知Java的一些异步API的执行，此函数通常用于创建和Java API相关的Promise，在Java API返回之前保持程序运行。
   *
   * @param executor
   * @returns
   *
   * @eng
   *
   * Creates a Promise, which is similar to `new Promise`, but it will keep the engine running when the Promise is in the pending state (before resolve/reject).
   *
   * Because nodejs does not know the asynchronous behavior of Java APIs, this function is usually used to create a Promise for a Java API, and keep the engine running until the Java API returns.
   *
   * @param executor
   * @returns
   *
   * @example
   * ```javascript
   * "nodejs";
   * const { promise } = require('lang');
   * const { android } = require('android');
   *
   * function loadAudioAsync(file) {
   *   const SoundPool = android.media.SoundPool;
   *   return promise(function (resolve) {
   *      const soundPool = new SoundPool(1, SoundPool.STREAM_MUSIC, 0);
   *      soundPool.setOnLoadCompleteListener($autojs.java.wrap(() => resolve(soundPool)));
   *      soundPool.load(file, 1);
   *   });
   * }
   *
   * ```
   */
  export declare function promise<T>(executor: (resolve: (value: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void): Promise<T>;
  /**
   * @中文
   *
   * 返回一个Promise，将在timeout时间后resolve。例如`await delay(1000)`会在1秒后执行。不同于Pro 8的`sleep()`，此函数并不会真正阻塞线程/事件循环。
   *
   * @param timeout 超时时间，若小于或等于0，则此函数返回一个立即resolve的Promise。
   * @returns
   *
   * @eng
   *
   * Returns a Promise, which will resolve after timeout. For example, `await delay(1000)` will resolve after 1 second. This function does not block the thread/event loop.
   *
   * @param timeout timeout, if less than or equal to 0, then the function returns a Promise that resolves immediately.
   * @returns
   *
   * @example
   * ```javascript
   * "nodejs";
   * const { delay } = require('lang');
   * async function main() {
   *   console.log(1);
   *   await delay(2000);
   *   console.log(2);
   * }
   * main();
   * ```
   *
   */
  export declare function delay(timeout: number): Promise<void>;
  /**
   * @中文
   *
   * Deferred类，用于创建Promise的延迟对象，而无需使用`new Promise`。通过resolve或reject函数可以设置Promise的状态。
   *
   * @eng
   *
   * A Deferred that can be completed via public functions resolve or reject. Unlike the Promise class, this class does not require the `new` keyword.
   *
   * @example
   * ```javascript
   * "nodejs";
   * const { Deferred } = require('lang');
   * async function main() {
   *     console.log(await add(1, 2));
   * }
   * main();
   *
   * function add(a, b) {
   *     const d = new Deferred();
   *     setTimeout(() => {
   *         d.resolve(a + b);
   *     }, 1000);
   *     return d.promise();
   * }
   */
  export declare class Deferred<T> {
      private resolver?;
      private rejecter?;
      private finished;
      private _value?;
      private keepRunningId?;
      private _promise;
      constructor(keepRunning?: boolean);
      /**
       * @中文
       *
       * 使用给定的值设置Promise的状态为fulfilled。若已经是fulfilled或rejected状态，则返回false。
       *
       * @eng
       *
       * Sets the state of the Promise to fulfilled using the given value. If the Promise is already fulfilled or rejected, returns false.
       *
       */
      resolve(value: T): boolean;
      /**
       * @中文
       *
       * 使用给定的reason作为原因或异常设置Promise的状态为rejected。若已经resolved或rejected状态，则返回false。
       *
       * @eng
       *
       * Sets the state of the Promise to rejected using the given reason or exception. If the Promise is already fulfilled or rejected, returns false.
       */
      reject(reason?: any): boolean;
      private finish;
      promise(): Promise<T>;
      /**
       * @中文
       *
       * 获取Deferred的值，如果为pending或rejected状态，则返回undefined。
       *
       * @eng
       *
       * Gets the value of the Deferred, if it is pending or rejected, then returns undefined.
       */
      get value(): T | undefined;
  }
  

}

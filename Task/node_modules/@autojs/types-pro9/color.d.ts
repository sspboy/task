/// <reference types="node" />

declare module 'color' {

  /**
   * @中文
   *
   * color模块包含了颜色相关的类，最常用的是Color类，表示ARGB颜色。
   *
   * @eng
   *
   * The color module contains classes for color, the most common is Color, which represents ARGB color.
   *
   * @see {@link Color}
   *
   * @packageDocumentation
   */
  import * as util from 'util';
  /**
   * @中文
   *
   * 比较颜色的选项。
   *
   * @eng
   *
   * Compare color options.
   *
   * @see {@lin Color.isSimilarTo}
   */
  export interface CompareColorOptions {
      /**
       * @中文
       *
       * 是否忽略alpha通道，默认为true。
       *
       * @eng
       *
       * Whether to ignore alpha channel, default is true.
       */
      readonly ignoreAlphaChannel?: boolean;
      /**
       * @中文
       *
       * 允许的比较误差，默认为16。比较算法是将每个颜色通道单独比较，如果每个颜色通道的差值都小于该值，则认为两个颜色相等。
       *
       * @eng
       *
       * Allowed comparison threshold, default is 16. Comparison algorithm is to compare each color channel separately, if the difference between each color channel is less than the threshold, the two colors are considered equal.
       */
      readonly threshold?: number;
  }
  /**
   * @中文
   *
   * 一个32位的颜色值，以ARGB格式表示。
   *
   * @eng
   *
   * An immutable 32 bit color value in ARGB format.
   *
   */
  export declare class Color {
      private _value;
      /**
       * @中文
       *
       * 从整数颜色值构造一个颜色。
       *
       * @param value 整数颜色值，格式为0xAARRGGBB
       *
       * @eng
       *
       * Constructs a color from an integer value.
       *
       * @param value An integer value, formatted as 0xAARRGGBB
       */
      constructor(value: number);
      /**
       * @eng
       *
       * A 32 bit value representing this color.
       *
       * The bits are assigned as follows:
       *
       * * Bits 24-31 are the alpha value.
       * * Bits 16-23 are the red value.
       * * Bits 8-15 are the green value.
       * * Bits 0-7 are the blue value.
       *
       * @中文
       *
       * 这个颜色的32位值。
       *
       * * 第24-31位为alpha值
       * * 第16-23位为red值
       * * 第8-15位为green值
       * * 第0-7位为blue值
       */
      get value(): number;
      /**
       * @eng
       *
       * The alpha channel of this color in an 8 bit value.
       *
       * A value of 0 means this color is fully transparent. A value of 255 means
       * this color is fully opaque.
       *
       * @中文
       *
       * 这个颜色的alpha值，以8位整数表示。
       *
       * 值为0表示这个颜色完全透明，值为255表示这个颜色完全不透明。
       *
       * @example
       * ```javascript
       * "nodejs";
       * const { Color } = require('color');
       * const color = new Color(0xFF000000); // black
       * console.log(color.alpha); // 255
       * ```
       */
      get alpha(): number;
      /**
       * @eng
       *
       * The alpha channel of this color as a floating value.
       *
       * A value of 0.0 means this color is fully transparent. A value of 1.0 means
       * this color is fully opaque.
       *
       * @中文
       *
       * 这个颜色的alpha值，以浮点数表示。
       *
       * 值为0.0表示这个颜色完全透明，值为1.0表示这个颜色完全不透明。
       *
       * @example
       * ```javascript
       * "nodejs";
       * const { Color } = require('color');
       * const color = new Color(0xFF000000); // black
       * console.log(color.opacity); // 1.0
       * ```
       */
      get opacity(): number;
      /**
       * The red channel of this color in an 8 bit value.
       */
      get red(): number;
      /**
       * @eng
       *
       * The green channel of this color in an 8 bit value.
       *
       * @中文
       *
       * 这个颜色的green值，以8位整数表示。
       */
      get green(): number;
      /**
       * @eng
       *
       * The blue channel of this color in an 8 bit value.
       *
       * @中文
       *
       * 这个颜色的blue值，以8位整数表示。
       */
      get blue(): number;
      /**
       * @eng
       *
       * Returns a new color that matches this color with the alpha channel
       * replaced with `a` (which ranges from 0 to 255).
       *
       * Out of range values will have unexpected effects.
       *
       * @param a alpha channel
       * @returns a new color
       *
       * @中文
       *
       * 返回一个新的颜色，将原来的颜色的alpha通道的值设置为`a`
       *
       * 超出范围的值会有意外问题。
       *
       * @param a alpha通道的值，范围为0-255
       * @returns 新的颜色
       *
       * @example
       * ```javascript
       * "nodejs";
       * const { Color } = require('color');
       * const color = new Color(0xFF000000); // black
       * console.log(color.withAlpha(0x77).toString()) // 0x77000000
       * ```
       */
      withAlpha(a: number): Color;
      /**
       * @eng
       *
       * Returns a new color that matches this color with the alpha channel
       * replaced with the given `opacity` (which ranges from 0.0 to 1.0).
       *
       * Out of range values will have unexpected effects.
       *
       * @param opacity opacity value
       * @returns a new color
       *
       * @中文
       *
       * 返回一个新的颜色，将原来的颜色的alpha通道的透明度值设置为`opacity`。
       *
       * 超出范围的值会有意外问题。
       *
       * @param opacity 透明度值，范围为0.0-1.0
       * @returns 新的颜色
       *
       * @example
       * ```javascript
       * "nodejs";
       * const { Color } = require('color');
       * const color = new Color(0xFF000000); // black
       * console.log(color.withOpacity(0.5).toString()) // 0x7F000000
       * ```
       */
      withOpacity(opacity: number): Color;
      /**
       * @eng
       *
       * Returns a new color that matches this color with the red channel replaced
       * with `r` (which ranges from 0 to 255).
       *
       * Out of range values will have unexpected effects.
       *
       * @param r red channel
       * @returns a new color
       *
       * @中文
       *
       * 返回一个新的颜色，将原来的颜色的red通道的值设置为`r`。
       *
       * 超出范围的值会有意外问题。
       *
       * @param r red通道的值，范围为0-255
       * @returns 新的颜色
       */
      withRed(r: number): Color;
      /**
       * @eng
       *
       * Returns a new color that matches this color with the green channel
       * replaced with `g` (which ranges from 0 to 255).
       *
       * Out of range values will have unexpected effects.
       *
       * @param g green channel
       * @returns a new color
       *
       * @中文
       *
       * 返回一个新的颜色，将原来的颜色的green通道的值设置为`g`。
       *
       * 超出范围的值会有意外问题。
       *
       * @param g green通道的值，范围为0-255
       * @returns 新的颜色
       */
      withGreen(g: number): Color;
      /**
       * @eng
       *
       * Returns a new color that matches this color with the blue channel replaced
       * with `b` (which ranges from 0 to 255).
       *
       * Out of range values will have unexpected effects.
       *
       * @param b blue channel
       * @returns a new color
       *
       * @中文
       *
       * 返回一个新的颜色，将原来的颜色的blue通道的值设置为`b`。
       *
       * 超出范围的值会有意外问题。
       *
       * @param b blue通道的值，范围为0-255
       * @returns 新的颜色
       *
       */
      withBlue(b: number): Color;
      /**
       * @中文
       *
       * 比较当前颜色是否与另一个颜色相似。
       *
       * @param other 要比较的颜色
       * @param options 比较选项
       * @returns 两个颜色是否相似
       *
       * @see {@link CompareColorOptions}
       *
       * @example
       *
       * ```javascript
       * "nodejs";
       * const { Color } = require('color');
       * const black = new Color(0xFF000000);
       * const white = Color.parse('#FFFFFF');
       * const black09 = Color.parse('#090909');
       * console.log(black.isSimilarTo(white)) // false
       * console.log(black.isSimilarTo(black09)) // true
       * console.log(black.isSimilarTo(black09, { threshold: 5 })) // false
       */
      isSimilarTo(other: Color, options?: CompareColorOptions): boolean;
      /**
       * @中文
       *
       * 比较两个颜色是否完全相等。
       *
       * @param other 要比较的颜色
       * @returns 两个颜色是否完全相等
       *
       * @eng
       *
       * Compare two colors is equal, including alpha channel.
       *
       * @param other the color to compare
       * @returns two colors are equal
       */
      equals(obj: Color): boolean;
      toString: () => string;
      [util.inspect.custom]: () => string;
      /**
       * @eng
       *
       * Construct a color from the lower 8 bits of four integers.
       *
       * * `a` is the alpha value, with 0 being transparent and 255 being fully
       *   opaque.
       * * `r` is [red], from 0 to 255.
       * * `g` is [green], from 0 to 255.
       * * `b` is [blue], from 0 to 255.
       *
       * Out of range values are brought into range using modulo 255.
       *
       * @param a alpha value
       * @param r red value
       * @param g green value
       * @param b blue value
       * @returns a new color
       *
       * @中文
       *
       * 从四个颜色通道构造一个颜色。
       *
       * * `a`是透明度，0表示透明，255表示完全不透明。
       * * `r`是[红]，范围为0-255。
       * * `g`是[绿]，范围为0-255。
       * * `b`是[蓝]，范围为0-255。
       *
       * 超出范围的值会取255的模以保证在255范围内。
       *
       * @param a alpha通道的值，范围为0-255
       * @param r red通道的值，范围为0-255
       * @param g green通道的值，范围为0-255
       * @param b blue通道的值，范围为0-255
       * @returns 新的颜色
       *
       * @see {@link fromRGBO} which takes the alpha value as a floating point
       * value.
       *
       * @example
       * ```javascript
       * "nodejs";
       * const { Color } = require('color');
       * const red = Color.fromARGB(255, 255, 0, 0);
       * console.log(red.toString()) // Color(0xFFFF0000)
       * ```
       *
       */
      static fromARGB(a: number, r: number, g: number, b: number): Color;
      /**
       * @中文
       *
       * 从RGB颜色通道构造一个不透明颜色（alpha通道为255）。
       *
       * @param r red value
       * @param g green value
       * @param b blue value
       * @returns a new color
       *
       * @eng
       *
       * Construct a color from RGB channels. The alpha channel is set to 255.
       *
       * @param r 红色通道的值，范围为0-255
       * @param g 绿色通道的值，范围为0-255
       * @param b 蓝色通道的值，范围为0-255
       * @returns 新的颜色对象
       *
       * @example
       * ```javascript
       * "nodejs";
       * const { Color } = require('color');
       * const red = Color.fromRGBO(255, 0, 0);
       * console.log(red.toString()) // Color(0xFFFF0000)
       * ```
       */
      static fromRGB(r: number, g: number, b: number): Color;
      /**
       * @中文
       *
       * 根据灰度值构造颜色，alpha通道为255，R、G、B通道均为gray的值。
       *
       * @param gray 灰度值
       * @returns 新的颜色对象
       *
       * @eng
       *
       * Construct a color from a grayscale value. The alpha channel is set to 255, and the R, G, and B channels are set to the same value.
       *
       * @param gray the grayscale value
       * @returns a new color
       *
       * @example
       * ```javascript
       * "nodejs";
       * const { Color } = require('color');
       * const gray = Color.fromGray(128);
       * console.log(gray.toString()) // Color(0xFF808080)
       * ```
       */
      static fromGray(gray: number): Color;
      /**
       * @eng
       *
       * Create a color from red, green, blue, and opacity, similar to `rgba()` in CSS.
       *
       * * `r` is [red], from 0 to 255.
       * * `g` is [green], from 0 to 255.
       * * `b` is [blue], from 0 to 255.
       * * `opacity` is alpha channel of this color as a double, with 0.0 being
       *   transparent and 1.0 being fully opaque.
       *
       * Out of range values are brought into range using modulo 255.
       *
       * @param r red value
       * @param g green value
       * @param b blue value
       * @param opacity alpha value
       * @returns a new color
       *
       * @中文
       *
       * 从红、绿、蓝和透明度通道构造一个颜色。
       *
       * * `r`是[红]，范围为0-255。
       * * `g`是[绿]，范围为0-255。
       * * `b`是[蓝]，范围为0-255。
       * * `opacity`是透明度通道的值，0表示透明，1表示完全不透明。
       *
       * 超出范围的值会取255的模以保证在255范围内。
       *
       * @param r red通道的值，范围为0-255
       * @param g green通道的值，范围为0-255
       * @param b blue通道的值，范围为0-255
       * @param opacity alpha通道的值，范围为0-1
       * @returns 新的颜色
       *
       * @see {@link fromARGB} which takes the opacity as an integer value.
       *
       */
      static fromRGBO(r: number, g: number, b: number, opacity: number): Color;
      /**
       * @中文
       *
       * 解析十六进制字符串构造一个颜色。若解析失败，则返回null。
       *
       * @param color 颜色字符串，格式为#RRGGBB或#AARRGGBB
       * @returns 新的颜色，或者null
       *
       * @eng
       *
       * Parse a color from a hex string, such as `#RRGGBB` or `#AARRGGBB`.
       *
       * @param color 颜色字符串，格式为#RRGGBB或#AARRGGBB
       * @returns 新的颜色，或者null
       *
       * @example
       * ```javascript
       * const { Color } = require('color');
       * const color = Color.parse('#ff0000');
       * console.log(color.toString());
       * ```
       */
      static parse(color: string): Color | null;
  }
  /**
   *
   * @中文
   *
   * 转换整数number为颜色整数。该函数实际上是将大于int32最大值的数字转换为负数，例如将0xFFFFFFFF转换为-1。
   *
   * @param number 整数
   * @returns 颜色整数
   *
   * @eng
   *
   * Convert a number to a color integer. The actual implementation is to convert the number that larger than int32 max to a negative number. For example, 0xFFFFFFFF will be converted to -1.
   *
   * @param number integer
   * @returns color integer
   */
  export declare function toColorInt(number: number): number;
  /**
   * A color represented using [alpha], [hue], [saturation], and [value].
   * An [HSVColor] is represented in a parameter space that's based on human
   * perception of color in pigments (e.g. paint and printer's ink). The
   * representation is useful for some color computations (e.g. rotating the hue
   * through the colors), because interpolation and picking of
   * colors as red, green, and blue channels doesn't always produce intuitive
   * results.
   * The HSV color space models the way that different pigments are perceived
   * when mixed. The hue describes which pigment is used, the saturation
   * describes which shade of the pigment, and the value resembles mixing the
   * pigment with different amounts of black or white pigment.
   * See also:
   *  * [HSLColor], a color that uses a color space based on human perception of
   *    colored light.
   *  * [HSV and HSL](https://en.wikipedia.org/wiki/HSL_and_HSV) Wikipedia
   *    article, which this implementation is based upon.
   */
  export declare class HSVColor {
      /**
       * Creates a color.
       *
       * All the arguments must not be null and be in their respective ranges. See
       * the fields for each parameter for a description of their ranges.
       */
      static fromAHSV(alpha: number, hue: number, saturation: number, value: number): HSVColor;
      /**
       * Creates an [HSVColor] from an RGB [Color].
       *
       * This constructor does not necessarily round-trip with [toColor] because
       * of floating point imprecision.
       */
      static fromColor(color: Color): HSVColor;
      /**
       * Alpha, from 0.0 to 1.0. The describes the transparency of the color.
       * A value of 0.0 is fully transparent, and 1.0 is fully opaque.
       */
      readonly alpha: number;
      /**
       * Hue, from 0.0 to 360.0. Describes which color of the spectrum is
       * represented. A value of 0.0 represents red, as does 360.0. Values in
       * between go through all the hues representable in RGB. You can think of
       * this as selecting which pigment will be added to a color.
       */
      readonly hue: number;
      /**
       * Saturation, from 0.0 to 1.0. This describes how colorful the color is.
       * 0.0 implies a shade of grey (i.e. no pigment), and 1.0 implies a color as
       * vibrant as that hue gets. You can think of this as the equivalent of
       * how much of a pigment is added.
       */
      readonly saturation: number;
      /**
       * Value, from 0.0 to 1.0. The "value" of a color that, in this context,
       * describes how bright a color is. A value of 0.0 indicates black, and 1.0
       * indicates full intensity color. You can think of this as the equivalent of
       * removing black from the color as value increases.
       */
      readonly value: number;
      private constructor();
      /**
       * Returns a copy of this color with the [alpha] parameter replaced with the
       * given value.
       */
      withAlpha(alpha: number): HSVColor;
      /**
       * Returns a copy of this color with the [hue] parameter replaced with the
       * given value.
       */
      withHue(hue: number): HSVColor;
      /**
       * Returns a copy of this color with the [saturation] parameter replaced with
       * the given value.
       */
      withSaturation(saturation: number): HSVColor;
      /**
       * Returns a copy of this color with the [value] parameter replaced with the
       * given value.
       */
      withValue(value: number): HSVColor;
      /**
       * Returns this color in RGB.
       */
      toColor(): Color;
      _scaleAlpha(factor: number): HSVColor;
      /**
       * Linearly interpolate between two HSVColors.
       *
       * The colors are interpolated by interpolating the [alpha], [hue],
       * [saturation], and [value] channels separately, which usually leads to a
       * more pleasing effect than [Color.lerp] (which interpolates the red, green,
       * and blue channels separately).
       *
       * If either color is null, this function linearly interpolates from a
       * transparent instance of the other color. This is usually preferable to
       * interpolating from [Colors.transparent] (`const Color(0x00000000)`) since
       * that will interpolate from a transparent red and cycle through the hues to
       * match the target color, regardless of what that color's hue is.
       *
       * Values outside of the valid range for each channel will be clamped.
       */
      static lerp(a: HSVColor | null, b: HSVColor | null, t: number): HSVColor | undefined;
      equals(other: any): boolean;
      toString(): string;
  }
  /**
   * A color represented using [alpha], [hue], [saturation], and [lightness].
   *
   * An [HSLColor] is represented in a parameter space that's based up human
   * perception of colored light. The representation is useful for some color
   * computations (e.g., combining colors of light), because interpolation and
   * picking of colors as red, green, and blue channels doesn't always produce
   * intuitive results.
   *
   * HSL is a perceptual color model, placing fully saturated colors around a
   * circle (conceptually) at a lightness of ​0.5, with a lightness of 0.0 being
   * completely black, and a lightness of 1.0 being completely white. As the
   * lightness increases or decreases from 0.5, the apparent saturation decreases
   * proportionally (even though the [saturation] parameter hasn't changed).
   *
   * See also:
   *
   *  * [HSVColor], a color that uses a color space based on human perception of
   *    pigments (e.g. paint and printer's ink).
   *  * [HSV and HSL](https://en.wikipedia.org/wiki/HSL_and_HSV) Wikipedia
   *    article, which this implementation is based upon.
   */
  export declare class HSLColor {
      /**
       * Creates a color.
       *
       * All the arguments must not be null and be in their respective ranges. See
       * the fields for each parameter for a description of their ranges.
       */
      static fromAHSL(alpha: number, hue: number, saturation: number, lightness: number): HSLColor;
      /**
       * Creates an [HSLColor] from an RGB [Color].
       *
       * This constructor does not necessarily round-trip with [toColor] because
       * of floating point imprecision.
       */
      static fromColor(color: Color): HSLColor;
      /**
       * Alpha, from 0.0 to 1.0. The describes the transparency of the color.
       * A value of 0.0 is fully transparent, and 1.0 is fully opaque.
       */
      readonly alpha: number;
      /**
       * Hue, from 0.0 to 360.0. Describes which color of the spectrum is
       * represented. A value of 0.0 represents red, as does 360.0. Values in
       * between go through all the hues representable in RGB. You can think of
       * this as selecting which color filter is placed over a light.
       */
      readonly hue: number;
      /**
       * Saturation, from 0.0 to 1.0. This describes how colorful the color is.
       * 0.0 implies a shade of grey (i.e. no pigment), and 1.0 implies a color as
       * vibrant as that hue gets. You can think of this as the purity of the
       * color filter over the light.
       */
      readonly saturation: number;
      /**
       * Lightness, from 0.0 to 1.0. The lightness of a color describes how bright
       * a color is. A value of 0.0 indicates black, and 1.0 indicates white. You
       * can think of this as the intensity of the light behind the filter. As the
       * lightness approaches 0.5, the colors get brighter and appear more
       * saturated, and over 0.5, the colors start to become less saturated and
       * approach white at 1.0.
       */
      readonly lightness: number;
      private constructor();
      /**
       * Returns a copy of this color with the alpha parameter replaced with the
       * given value.
       */
      withAlpha(alpha: number): HSLColor;
      /**
       * Returns a copy of this color with the [hue] parameter replaced with the
       * given value.
       */
      withHue(hue: number): HSLColor;
      /**
       * Returns a copy of this color with the [saturation] parameter replaced with
       * the given value.
       */
      withSaturation(saturation: number): HSLColor;
      /**
       * Returns a copy of this color with the [lightness] parameter replaced with
       * the given value.
       */
      withLightness(lightness: number): HSLColor;
      /**
       * Returns this HSL color in RGB.
       */
      toColor(): Color;
      _scaleAlpha(factor: number): HSLColor;
      /**
       * Linearly interpolate between two HSLColors.
       *
       * The colors are interpolated by interpolating the [alpha], [hue],
       * [saturation], and [lightness] channels separately, which usually leads to
       * a more pleasing effect than [Color.lerp] (which interpolates the red,
       * green, and blue channels separately).
       *
       * If either color is null, this function linearly interpolates from a
       * transparent instance of the other color. This is usually preferable to
       * interpolating from [Colors.transparent] (`const Color(0x00000000)`) since
       * that will interpolate from a transparent red and cycle through the hues to
       * match the target color, regardless of what that color's hue is.
       *
       * The `t` argument represents position on the timeline, with 0.0 meaning
       * that the interpolation has not started, returning `a` (or something
       * equivalent to `a`), 1.0 meaning that the interpolation has finished,
       * returning `b` (or something equivalent to `b`), and values between them
       * meaning that the interpolation is at the relevant point on the timeline
       * between `a` and `b`. The interpolation can be extrapolated beyond 0.0 and
       * 1.0, so negative values and values greater than 1.0 are valid
       * (and can easily be generated by curves such as [Curves.elasticInOut]).
       *
       * Values outside of the valid range for each channel will be clamped.
       *
       * Values for `t` are usually obtained from an [Animation<double>], such as
       * an [AnimationController].
       */
      static lerp(a: HSLColor | null, b: HSLColor | null, t: number): HSLColor | null;
      equals(other: any): boolean;
      toString(): String;
  }
  

}
